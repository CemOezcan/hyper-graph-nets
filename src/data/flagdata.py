
import torch
import os

from torch.utils.data import Dataset, IterableDataset
from tfrecord.torch.dataset import TFRecordDataset
from src.util import NodeType, device


class FlagSimpleDatasetIterative(IterableDataset):
    def __init__(self, path, split, add_targets=False, split_and_preprocess=False):
        self.path = path
        self.split = split
        self._add_targets = add_targets
        self._split_and_preprocess = split_and_preprocess
        '''
        self.add_targets = add_targets
        self.split_and_preprocess = split_and_preprocess
        '''
        tfrecord_path = os.path.join(path, split + ".tfrecord")
        # index is generated by tfrecord2idx
        index_path = os.path.join(path, split + ".idx")
        tf_dataset = TFRecordDataset(tfrecord_path, index_path, None)
        # loader and iter(loader) have size 1000, which is the number of all training trajectories
        loader = torch.utils.data.DataLoader(tf_dataset, batch_size=1)
        # use list to make list from iterable so that the order of elements is ensured
        self.dataset = iter(loader)

    def __iter__(self):
        return self.dataset

    def add_targets(self):
        """Adds target and optionally history fields to dataframe."""
        fields = 'world_pos'
        add_history = True

        def fn(trajectory):
            out = {}
            for key, val in trajectory.items():
                out[key] = val[1:-1]
                if key in fields:
                    if add_history:
                        out['prev|' + key] = val[0:-2]
                    out['target|' + key] = val[2:]
            return out

        return fn

    def split_and_preprocess(self):
        """Splits trajectories into frames, and adds training noise."""
        noise_field = 'world_pos'
        noise_scale = 0.003
        noise_gamma = 0.1

        def add_noise(frame):
            zero_size = torch.zeros(frame[noise_field].size(), dtype=torch.float32).to(device)
            noise = torch.normal(zero_size, std=noise_scale).to(device)
            other = torch.Tensor([NodeType.NORMAL.value]).to(device)
            mask = torch.eq(frame['node_type'], other.int())[:, 0]
            mask = torch.stack((mask, mask, mask), dim=1)
            noise = torch.where(mask, noise, torch.zeros_like(noise))
            frame[noise_field] += noise
            frame['target|' + noise_field] += (1.0 - noise_gamma) * noise
            return frame

        def element_operation(trajectory):
            world_pos = trajectory['world_pos']
            mesh_pos = trajectory['mesh_pos']
            node_type = trajectory['node_type']
            cells = trajectory['cells']
            target_world_pos = trajectory['target|world_pos']
            prev_world_pos = trajectory['prev|world_pos']
            trajectory_steps = []
            for i in range(399):
                wp = world_pos[i]
                mp = mesh_pos[i]
                twp = target_world_pos[i]
                nt = node_type[i]
                c = cells[i]
                pwp = prev_world_pos[i]
                trajectory_step = {'world_pos': wp, 'mesh_pos': mp, 'node_type': nt, 'cells': c,
                                   'target|world_pos': twp, 'prev|world_pos': pwp}
                noisy_trajectory_step = add_noise(trajectory_step)
                trajectory_steps.append(noisy_trajectory_step)
            return trajectory_steps

        return element_operation
